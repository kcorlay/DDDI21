#Initial packages and loading of original data file using readr.


knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(naniar)
library(gt)


Original.Data <- read_csv("NYC_Wi-Fi_Hotspot_Locations.csv")
Wifi <- Original.Data


#------------------


#Code used to find the amount of rows and columns.


ncol(Wifi)
nrow(Wifi)


#------------------


#Renaming variable due to spelling error


colnames(Wifi)[21] <- "Council District"


#------------------


#Creating Data Table of variables and renaming columns


Document.variables <- data.frame(colnames(Wifi), "Definition")
colnames(Document.variables)[1] <- "Variable"
colnames(Document.variables)[2] <- "Definition"


#Recoding definitions per NYC Open Data


Document.variables[1, 2] <- "Identification number automatically generated by map software ArcMap."
Document.variables[2, 2] <- "Borough of New York City. MN = Manhattan, BX = Bronx, BK = Brooklyn, QU = Queens, SI = Staten Island."
Document.variables[3, 2] <- "Type of WiFi provided by franchise."
Document.variables[4, 2] <- "Franchise who is providing the WiFi connection."
Document.variables[5, 2] <- "The name of the location where the WiFi is located."
Document.variables[6, 2] <- "A brief description of where the WiFi point is."
Document.variables[7, 2] <- "Points that fall North or South of the Equator, expressed in degrees."
Document.variables[8, 2] <- "Points that fall East or West of the Prime Meridian, expressed in degrees."
Document.variables[9, 2] <- "A horizontal value where a point is located."
Document.variables[10, 2] <- "A vertical value where a point is located."
Document.variables[11, 2] <- "The type of location that a WiFi hotspot is present in."
Document.variables[12, 2] <- "Comments describing a specific hotspot or location."
Document.variables[13, 2] <- "The city in which a hotspot is located."
Document.variables[14, 2] <- "The name of the WiFi seen on people's devices."
Document.variables[15, 2] <- "A LinkNYC Kiosk's unique identification number."
Document.variables[16, 2] <- "The approximated date that this Wi-Fi site went active."
Document.variables[17, 2] <- "The New York City borough where the hotspots are located. 1 = Manhattan, 2 = Bronx, 3 = Brooklyn, 4 = Queens, 5 = Staten Island."
Document.variables[18, 2] <- "The New York City borough where the hotspots are located."
Document.variables[19, 2] <- "Four (4) digit code assigned to neighborhoods to differentiate NYC's five boroughs."
Document.variables[20, 2] <- "Neighborhood identifiers to differentiate NYC's five boroughs."
Document.variables[21, 2] <- "NYC City Council District number."
Document.variables[22, 2] <- "United States Postal Service Zip Code (5-digits)."
Document.variables[23, 2] <- "New York City Borough plus Community Board Numbers."
Document.variables[24, 2] <- "2010 U.S. Census data based on location."
Document.variables[25, 2] <- "Combined value of Borough CD and Census 2010."
Document.variables[26, 2] <- "Building Identification Number."
Document.variables[27, 2] <- "Borough Block Lot."
Document.variables[28, 2] <- "Identification number automatically generated by GIS Developer map sites."
Document.variables[29, 2] <- "Combination of the latitude and longitude values."


#Final table output using gt package


Document.variables %>%
  gt() %>%
  tab_header(
    title = "NYC Wi-Fi Hotspot Locations Documentation"
  ) %>%
  tab_source_note(
    source_note = "Table 1.1"
  ) %>%
  tab_source_note(
    source_note =  ("Source: NYC Open Data, 2020.")
  )


#------------------


#Recoding values as NA for several variables


Wifi <- Wifi %>%
  naniar::replace_with_na(replace = list(BBL = 0,
                                         Activated = "09/09/9999",
                                         BIN = 0,
                                         Name = 0,
                                         SourceID = 0))


#------------------


#Recoding Borough number codes to character abbreviations


Wifi$Borough[Wifi$Borough == 1] <- "MN"
Wifi$Borough[Wifi$Borough == 2] <- "BX"
Wifi$Borough[Wifi$Borough == 3] <- "BK"
Wifi$Borough[Wifi$Borough == 4] <- "QU"
Wifi$Borough[Wifi$Borough == 5] <- "SI"


#------------------


#Checking for NA values within each variable


sapply(Wifi, function(x) sum(is.na(x)))


#Binary flags for every variable based on missing data using ifelse statement. A missing (NA) observation will appear as a 1.


Wifi$BF_Activated <- ifelse(is.na(Wifi$Activated) == TRUE, 1, 0)
Wifi$BF_Name <- ifelse(is.na(Wifi$Name) == TRUE, 1, 0)
Wifi$BF_BIN <- ifelse(is.na(Wifi$BIN) == TRUE, 1, 0)
Wifi$BF_Remarks <- ifelse(is.na(Wifi$Remarks) == TRUE, 1, 0)
Wifi$BF_SourceID <- ifelse(is.na(Wifi$SourceID) == TRUE, 1, 0)
Wifi$BF_BBL <- ifelse(is.na(Wifi$BBL) == TRUE, 1, 0)


#------------------


#Percentage of each variable that is missing 


sapply(Wifi, function(x) {
  (sum(is.na(x)) / length(x)) * 100
}
)


#------------------


#Created ID variable


Wifi$ID <- rownames(Wifi)


#FOrmatting Activated dates properly using Lubridate


Wifi$Activated <- mdy(Wifi$Activated)


#Also checking if BCT is the same as census tract. This is the same previous check. Since it is the same (sum = 0) I chose to remove it.


censustractcheck <- ifelse(Wifi$`Census Tract` == Wifi$BCTCB2010, 0, 1)
sum(censustractcheck)

Wifi <- Wifi %>%
  select(-BCTCB2010)


#------------------


#No mismatches in the Brooklyn borough


brooklyn <- Wifi %>%
  filter(City != `Borough Name`) %>%
  select(City, `Borough Name`, `Neighborhood Tabulation Area Code (NTACODE)`) %>%
  filter(`Borough Name` == "Brooklyn")


#No mismatches for Staten island borough


Staten_Island <- Wifi %>%
  filter(City != `Borough Name`) %>%
  select(City, `Borough Name`, `Neighborhood Tabulation Area Code (NTACODE)`) %>%
  filter(`Borough Name` == "Staten Island")


#No mismatches in Bronx borough


Bronx <- Wifi %>%
  filter(City != `Borough Name`) %>%
  select(City, `Borough Name`, `Neighborhood Tabulation Area Code (NTACODE)`) %>%
  filter(`Borough Name` == "Bronx")


#There is one where Brooklyn is encoded to Manhattan. Otherwise New York in city is encoded to Manhattan borough.


Manhattan <- Wifi %>%
  filter(City != `Borough Name`) %>%
  select(City, `Borough Name`, `Neighborhood Tabulation Area (NTA)`, OBJECTID) %>%
  filter(`Borough Name` == "Manhattan") %>%
  filter(City != "New York")


#Recoding values that don't match Manhattan borough


Wifi$City[Wifi$City == "New York"] <- "Manhattan"
Wifi[1263, 13] <- "Manhattan"


#Queens has many incorrect values. These values for City are similar to NTA but slightly different. This includes setting Brooklyn or other boroughs within the Queens borough.


queens <- Wifi %>%
  filter(City != `Borough Name`) %>%
  select(City, `Borough Name`, `Neighborhood Tabulation Area (NTA)`, `Neighborhood Tabulation Area Code (NTACODE)`, OBJECTID) %>%
  filter(`Borough Name` == "Queens")


#Removing City variable from dataset


Wifi <- Wifi %>%
  select(-City)


#------------------


#Replacing Location (Lat, Long) with exact values specified in Latitude and Longitude


LongLat1 <- str_c(Wifi$Latitude, Wifi$Longitude, sep = ", ")
LongLat2 <- str_c("(", LongLat1, ")", sep = "")
Wifi$`Location (Lat, Long)` <- LongLat2


#------------------


#Recoding categorical variables as factors


Wifi$Borough <- as.factor(Wifi$Borough)
Wifi$Type <- as.factor(Wifi$Type)
Wifi$Provider <- as.factor(Wifi$Provider)
Wifi$`Location_T` <- as.factor(Wifi$`Location_T`)
Wifi$`Borough Name` <- as.factor(Wifi$`Borough Name`)
Wifi$BoroCode <- as.factor(Wifi$BoroCode)


#------------------


#Recoding Location_T to more concise categories


Wifi$Location_T[Wifi$Location_T == "Indoor AP - Queens Public Library"] <- "Library"

Wifi$Location_T[Wifi$Location_T == "Outdoor TWC Aerial"] <- "Outdoor"

Wifi$Location_T[Wifi$Location_T == "Indoor AP - South Maintenance Area" |
                  Wifi$Location_T == "Indoor AP - South Management Office" |
                  Wifi$Location_T == "Indoor AP - Community Center - Activity Rm 2" |
                  Wifi$Location_T == "Indoor AP - Community Center - Computer Rm" |
                  Wifi$Location_T == "Indoor AP - North Maintenance Area" |
                  Wifi$Location_T == "Indoor AP - North Management Office" |
                  Wifi$Location_T == "Indoor AP - Community Center - Gym" |
                  Wifi$Location_T == "Indoor AP - Community Center - Activity Rm 1"|
                  Wifi$Location_T == "Indoor AP - Community Center - Cafeteria"] <- "Indoor"


#Creating Indoor binary variable


Wifi$Indoor <- ifelse(Wifi$Location_T == "Indoor" |
                        Wifi$Location_T == "Library", 1, 0)


#Creating subway binary variable


Wifi$Subway <- ifelse(Wifi$Location_T == "Subway Station", 1, 0)
sum(Wifi$Subway)


#Verification of subway variable, since both the sum of Subway variable and subwaycheck are 276 it is correct


SubwayCheck <- Wifi %>%
  filter(SSID == "TransitWirelessWiFi")
nrow(SubwayCheck)


#------------------


#Categorizing mailing addresses from properly coded indoor locations.


Wifi$IndoorAddress <- ifelse(Wifi$Indoor == 1 &
                               Wifi$Provider != "SPECTRUM" &
                               Wifi$Provider != "ALTICEUSA" &
                               Wifi$Provider != "Fiberless", Wifi$Location, NA)


#Separating address strings into street name and number


address <- str_split(Wifi$IndoorAddress, " ", n = 2, simplify = TRUE)
Wifi$StreetNumber <- address[, 1]
Wifi$StreetName <- address[, 2]


#Street name column only had the correct street name data, but instead of NA values had blank ones
#I used an ifelse statement to recode these as NA values.


Wifi$StreetName <- ifelse(!is.na(Wifi$StreetNumber) == TRUE, Wifi$StreetName, NA)


#Creating binary flag for missing data among these three variables


Wifi$BF_Address <- ifelse(is.na(Wifi$IndoorAddress) == TRUE |
                            is.na(Wifi$StreetNumber) == TRUE |
                            is.na(Wifi$StreetName) == TRUE, 1, 0)


#------------------


#Creating variable by joining existing information from Location and Name


Wifi$Directions <- ifelse(Wifi$Provider != "LinkNYC - Citybridge" &
                            Wifi$Provider != "Manhattan Down Alliance" &
                            !is.na(Wifi$Name) == TRUE, 
                          str_c(Wifi$Name, Wifi$Location, sep = ", "), NA)


#Add a binary flag for directions


Wifi$BF_Directions <- ifelse(is.na(Wifi$Directions) == TRUE, 1, 0)


#------------------


#Separate speed remarks into a new variable


Wifi$`Quality (MB)`[Wifi$Remarks == "Free - up to 5 mbs"] <- 5
Wifi$`Quality (MB)`[Wifi$Remarks == "Free - Up to 25 mbs Wi-Fi Service"] <- 25
Wifi$`Quality (MB)`[Wifi$Remarks == "Tablet Internet -phone , Free 1 GB Wi-FI Service"] <- 1000


#Add a binary flag for quality


Wifi$`BF_Quality (MB)` <- ifelse(is.na(Wifi$`Quality (MB)`) == TRUE, 1, 0)


#------------------


#Binary variable flag for free Wifi


Wifi$Free <- ifelse(Wifi$Type == "Free", 1, 0)


#------------------



#Addition of new variables to documentation table 


Document.variables[30, ] <- c("BF_Activated", "Binary flag for missing information in Activated variable.")
Document.variables[31, ] <- c("BF_Name", "Binary flag for missing information in Name variable.")
Document.variables[32, ] <- c("BF_BIN", "Binary flag for missing information in BIN variable.")
Document.variables[33, ] <- c("BF_Remarks", "Binary flag for missing information in Remarks variable.")
Document.variables[34, ] <- c("BF_SourceID", "Binary flag for missing information in SourceID variable.")
Document.variables[35, ] <- c("BF_BBL", "Binary flag for missing information in BBL variable.")
Document.variables[36, ] <- c("ID", "Unique row ID generated in R.")
Document.variables[37, ] <- c("Indoor", "Binary flag to distinguish between indoor and outdoor locations, where 1 is indoors.")
Document.variables[38, ] <- c("Subway", "Binary flag to distinguish subway locations, where 1 is within subways.")
Document.variables[39, ] <- c("Indoor Address", "Separated mailing addresses for indoor locations.")
Document.variables[40, ] <- c("StreetNumber", "Street number for indoor locations.")
Document.variables[41, ] <- c("StreetName", "Street name for indoor locations")
Document.variables[42, ] <- c("BF_Address", "Binary flag for missing information Indoor Address, StreetNumber, StreetName.")
Document.variables[43, ] <- c("Directions", "Combined Location and Name variable.")
Document.variables[44, ] <- c("BF_Directions", "Binary flag for missing information in Directions variable.")
Document.variables[45, ] <- c("Quality (MB)", "Internet speed provided by WiFi location in MB.")
Document.variables[46, ] <- c("BF_Quality (MB)", "Binary flag for missing information in Quality (MB) variable.")
Document.variables[47, ] <- c("Free", "Binary flag to distinguish free WiFi locations, where 1 is free")


#Second documentation table using gt package


Document.variables %>%
  gt() %>%
  tab_header(
    title = "NYC Wi-Fi Hotspot Locations Documentation"
  ) %>%
  tab_source_note(
    source_note = "Table 1.2"
  ) %>%
  tab_source_note(
    source_note =  ("Source: NYC Open Data, 2020.")
  )


#------------------


#Data frames to see most common provider by borough and NTA


CommonProvider.Borough <- Wifi %>%
  group_by(`Borough Name`, Provider) %>%
  summarize(Provider_Count = n()) %>%
  pivot_wider(names_from = Provider, values_from = Provider_Count)

CommonProvider.NTA <- Wifi %>%
  group_by(`Borough Name`, `Neighborhood Tabulation Area (NTA)` , Provider) %>%
  summarize(Provider_Count = n()) %>%
  pivot_wider(names_from = Provider, values_from = Provider_Count)


#Replacing NA values with 0


CommonProvider.Borough[is.na(CommonProvider.Borough)] <- 0

CommonProvider.NTA[is.na(CommonProvider.NTA)] <- 0


#Adding a column for most common provider in the previous dataframe


CommonProvider.Borough$Most_Common<- colnames(CommonProvider.Borough)[apply(CommonProvider.Borough, 1, which.max)]

CommonProvider.NTA$Most_Common<- colnames(CommonProvider.NTA)[apply(CommonProvider.NTA, 1, which.max)]


#The amount of WiFi sites per borough and NTA by adding a total column of providers


CommonProvider.Borough$Total_Sites <- rowSums(CommonProvider.Borough[2:18], na.rm = TRUE)

CommonProvider.NTA$Total_Sites <- rowSums(CommonProvider.NTA[3:19], na.rm = TRUE)


#------------------


#Data frames to see most common type of WiFi spot per borough and NTA


CommonType.Borough <- Wifi %>%
  group_by(`Borough Name`, Type) %>%
  summarize(Type_Count = n()) %>%
  pivot_wider(names_from = Type, values_from = Type_Count)

CommonType.NTA <- Wifi %>%
  group_by(`Borough Name`, `Neighborhood Tabulation Area (NTA)` , Type) %>%
  summarize(Type_Count = n()) %>%
  pivot_wider(names_from = Type, values_from = Type_Count)


#Setting NA values to 0


CommonType.Borough[is.na(CommonType.Borough)] <- 0

CommonType.NTA[is.na(CommonType.NTA)] <- 0


#Adding a most common type column to previous data frame


CommonType.Borough$Most_Common<- colnames(CommonType.Borough)[apply(CommonType.Borough, 1, which.max)]

CommonType.NTA$Most_Common<- colnames(CommonType.NTA)[apply(CommonType.NTA, 1, which.max)]


#Adding a total column (to use as a sum to calculate percent)


CommonType.Borough$Total_Sites <- rowSums(CommonType.Borough[2:4], na.rm = TRUE)

CommonType.NTA$Total_Sites <- rowSums(CommonType.NTA[3:5], na.rm = TRUE)


#Adding a percent free column. Dividing by total made in previous section.


CommonType.Borough <- CommonType.Borough %>%
  mutate(Percent.Free = (Free * 100) / Total_Sites)

CommonType.NTA <- CommonType.NTA %>%
  mutate(Percent.Free = (Free * 100) / Total_Sites)


#------------------


#Indoor vs outdoor for each borough/NTA, changing binary colnames to Indoor and Outdoor


Indoor.Borough <- Wifi %>%
  group_by(`Borough Name`, Indoor) %>%
  summarize(Indoor_Count = n()) %>%
  pivot_wider(names_from = Indoor, values_from = Indoor_Count)

colnames(Indoor.Borough)[2:3] <- c("Outdoor", "Indoor")


Indoor.NTA <- Wifi %>%
  group_by(`Borough Name`, `Neighborhood Tabulation Area (NTA)` , Indoor) %>%
  summarize(Indoor_Count = n()) %>%
  pivot_wider(names_from = Indoor, values_from = Indoor_Count)

colnames(Indoor.NTA)[3:4] <- c("Outdoor", "Indoor")


#Setting NA values to 0


Indoor.Borough[is.na(Indoor.Borough)] <- 0

Indoor.NTA[is.na(Indoor.NTA)] <- 0


#Adding a most common type column to previous data frame


Indoor.Borough$Most_Common<- colnames(Indoor.Borough)[apply(Indoor.Borough, 1, which.max)]

Indoor.NTA$Most_Common<- colnames(Indoor.NTA)[apply(Indoor.NTA, 1, which.max)]


#Adding a total column (to use as a sum to calculate percent)


Indoor.Borough$Total_Sites <- rowSums(Indoor.Borough[2:3], na.rm = TRUE)

Indoor.NTA$Total_Sites <- rowSums(Indoor.NTA[3:4], na.rm = TRUE)


#Adding a percent free column. Dividing by total made in previous section.


Indoor.Borough <- Indoor.Borough %>%
  mutate(Percent.Indoor = (Indoor * 100) / Total_Sites)

Indoor.NTA <- Indoor.NTA %>%
  mutate(Percent.Indoor = (Indoor * 100) / Total_Sites)


#------------------


#Average speed for each Borough. 


BoroughSpeed <- Wifi %>%
  select(`Borough Name`, `Quality (MB)`) %>%
  group_by(`Borough Name`) %>%
  filter(!(is.na(`Quality (MB)`)) == TRUE) %>%
  mutate(Av.Speed = mean(`Quality (MB)`)) %>%
  select(-`Quality (MB)`) %>%
  distinct()
BoroughSpeed


#------------------


#Average speed for indoor locations


IndoorQualityData <- Wifi %>%
  select(Indoor, `Quality (MB)`) %>%
  filter(!is.na(`Quality (MB)`) == TRUE & Indoor == 1)

IndoorQuality <- mean(IndoorQualityData$`Quality (MB)`)
IndoorQuality


#Average speed for outdoor locations


OutdoorQualityData <- Wifi %>%
  select(Indoor, `Quality (MB)`) %>%
  filter(!is.na(`Quality (MB)`) == TRUE & Indoor == 0)

OutdoorQuality <- mean(OutdoorQualityData$`Quality (MB)`)
OutdoorQuality


#Average speed for free locations


FreeQualityData <- Wifi %>%
  select(Free, `Quality (MB)`) %>%
  filter(!is.na(`Quality (MB)`) == TRUE & Free == 1)

FreeQuality <- mean(FreeQualityData$`Quality (MB)`)
FreeQuality


#Average speed for non-free locations is not available information


NotFreeQualityData <- Wifi %>%
  select(Free, `Quality (MB)`) %>%
  filter(!is.na(`Quality (MB)`) == TRUE & Free == 0)

NotFreeQuality <- mean(NotFreeQualityData$`Quality (MB)`)
NotFreeQuality


#------------------


#Table for Providers by borough


CommonProvider.Borough %>%
  ungroup(`Borough Name`) %>%
  gt(rowname_col = "Borough Name") %>%
  tab_header(
    title = "ISPs in NYC",
    subtitle = "WiFi ISP Distribution by NYC Borough (Feb. 2020)"
  ) %>%
  tab_spanner(
    label = "Internet Service Providers",
    columns = 2:18
  ) %>%
  cols_label(
    Most_Common = "Most Common",
    Total_Sites = "Total WiFi Sites"
  ) %>%
  fmt_number(
    columns = 2:18,
    sep_mark = ",",
    decimals = 0
  ) %>%
  tab_source_note(
    source_note = "Table 2"
  ) %>%
  tab_source_note(
    source_note =  ("Source: NYC Open Data, 2020.")
  )


#------------------


#Table for indoor vs outdoor per NTA


Indoor.NTA %>%
  ungroup(`Neighborhood Tabulation Area (NTA)`, Indoor) %>%
  gt() %>%
  tab_header(
    title = "WiFi Accessibility in NYC",
    subtitle = "WiFi Location by NYC Neighborhood (Feb. 2020)"
  ) %>%
  tab_spanner(
    label = "Location Type",
    columns = 3:4
  ) %>%
  cols_label(
    Most_Common = "Most Common",
    Total_Sites = "Total WiFi Sites",
    Percent.Indoor = "Percent of Location Indoor"
  ) %>%
  tab_source_note(
    source_note = "Table 3"
  ) %>%
  tab_source_note(
    source_note =  ("Source: NYC Open Data, 2020.")
  ) %>%
  fmt_number(
    columns = 7,
    decimals = 2
  )


#------------------

#Altering data frame and using gather to get data in a format to graph all three types


NewCommonType.Borough <- CommonType.Borough %>%
  select(-Percent.Free, -Most_Common) %>%
  gather("Type", "Value", -`Borough Name`)


#Graph of type per borough


ggplot(NewCommonType.Borough, mapping = aes(x = `Borough Name`, y = Value, fill = Type)) +
  geom_col(position = "dodge",
           size = 0.5) +
  labs(title = "Type of WiFi Locations in NYC by Borough (2020)",
       subtitle = "Distribution of Free, Limited, and Partner WiFi Sites",
       fill = "Type of Service") +
  ylab("Number of Sites") +
  xlab("NYC Borough") +
  theme_bw(base_size = 12) +
  scale_fill_discrete(labels = c("Free",
                                 "Limited Free",
                                 "Partner Site",
                                 "Total Sites"))


#------------------
